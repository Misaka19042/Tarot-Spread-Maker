<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¡”ç½—ç‰Œé˜µè‡ªå®šä¹‰æ¨æ¼”å™¨</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-colour: #2c3e50;
            --secondary-colour: #8b7355;
            --accent-colour: #d4af37;
            --background-colour: #f5f3f0;
            --card-shadow: 0 4px 8px rgba(0,0,0,0.2);
            --hover-shadow: 0 8px 16px rgba(0,0,0,0.3);
            --selection-outline: 2px solid #3498db; 
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Microsoft YaHei', 'SimSun', sans-serif; background-color: var(--background-colour); color: var(--primary-colour); line-height: 1.6; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { text-align: center; margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, var(--primary-colour), var(--secondary-colour)); color: white; border-radius: 10px; box-shadow: var(--card-shadow); }
        h1 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { font-style: italic; opacity: 0.9; }
        .tabs { display: flex; justify-content: center; margin-bottom: 30px; background: white; border-radius: 30px; padding: 5px; box-shadow: var(--card-shadow); }
        .tab { padding: 12px 30px; cursor: pointer; background: none; border: none; font-size: 1.1rem; color: var(--primary-colour); border-radius: 25px; transition: all 0.3s ease; font-weight: 500; }
        .tab.active { background: var(--accent-colour); color: white; box-shadow: 0 2px 10px rgba(212, 175, 55, 0.4); }
        .tab:hover:not(.active) { background: rgba(212, 175, 55, 0.1); }
        .tab-content { display: none; animation: fadeIn 0.5s ease; }
        .tab-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .spread-maker { display: grid; grid-template-columns: 300px 1fr; gap: 20px; height: 80vh; }
        .controls-panel { background: white; padding: 20px; border-radius: 10px; box-shadow: var(--card-shadow); overflow-y: auto; }
        .control-section { margin-bottom: 25px; }
        .control-section h3 { color: var(--secondary-colour); margin-bottom: 10px; font-size: 1.2rem; }
        
        .spread-canvas { background: #fff; border-radius: 10px; box-shadow: var(--card-shadow); position: relative; overflow: hidden; cursor: grab; }
        .spread-canvas.panning { cursor: grabbing; }
        #world { position: absolute; width: 10000px; height: 10000px; background-color: #fdfdfa; background-image: linear-gradient(rgba(139, 115, 85, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(139, 115, 85, 0.1) 1px, transparent 1px); background-size: 30px 30px; transform-origin: 0 0; }
        
        .tarot-card, .position-marker { position: absolute; cursor: move; user-select: none; transition: box-shadow 0.3s ease, outline 0.2s ease; border-radius: 8px; overflow: hidden; box-shadow: var(--card-shadow); }
        .tarot-card:hover, .position-marker:hover { box-shadow: var(--hover-shadow); z-index: 100; }
        .tarot-card.selected, .position-marker.selected { outline: var(--selection-outline); z-index: 99; }
        .tarot-card.dragging, .position-marker.dragging { opacity: 0.8; z-index: 1000; }
        .tarot-card { width: 197px; height: 342px; background: white; }
        .position-marker { width: 207px; height: 352px; background: rgba(212, 175, 55, 0.2); border: 2px dashed var(--accent-colour); display: flex; align-items: center; justify-content: center; font-size: 14px; color: var(--secondary-colour); font-weight: bold; padding: 5px; text-align: center; }
        
        .card-image { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .btn { padding: 10px 20px; background: var(--accent-colour); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; margin-right: 10px; margin-bottom: 10px; }
        .btn:hover { background: #b8941f; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn.secondary { background: var(--secondary-colour); }
        .btn.secondary:hover:not(:disabled) { background: #6d5a44; }
        .btn.danger { background: #e74c3c; }
        .btn.danger:hover:not(:disabled) { background: #c0392b; }
        .btn.small { padding: 5px 10px; font-size: 0.8rem; margin-top: 5px; }
        select, input[type="number"], input[type="text"] { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 1rem; margin-top: 5px; }
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 20px; padding: 20px; }
        .card-item { background: white; border-radius: 8px; padding: 10px; text-align: center; transition: all 0.3s ease; box-shadow: var(--card-shadow); display: flex; flex-direction: column; align-items: center; }
        .card-item .image-container { cursor: pointer; }
        .card-item:hover { transform: translateY(-5px); box-shadow: var(--hover-shadow); }
        .card-item img { width: 100%; max-width: 120px; height: 140px; object-fit: cover; border-radius: 4px; margin-bottom: 5px; border: 1px solid #eee; }
        .card-item h4 { font-size: 0.9rem; color: var(--primary-colour); margin-bottom: 5px; }
        .card-item .upload-actions { margin-top: 5px; display: flex; flex-direction: column; gap: 5px; width: 100%; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; animation: fadeIn 0.3s ease; }
        .modal-content { position: relative; background: white; max-width: 800px; margin: 50px auto; padding: 30px; border-radius: 10px; max-height: 80vh; overflow-y: auto; animation: slideIn 0.3s ease; }
        @keyframes slideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .close-modal { position: absolute; top: 10px; right: 10px; font-size: 2rem; cursor: pointer; color: #999; transition: color 0.3s ease; }
        .close-modal:hover { color: #333; }
        .spread-templates { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }
        .template-card { background: #f9f9f9; padding: 15px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s ease; border: 2px solid transparent; position: relative; }
        .template-card:hover { border-color: var(--accent-colour); transform: translateY(-3px); box-shadow: var(--hover-shadow); }
        .template-preview { width: 100%; height: 150px; background: white; border-radius: 4px; margin-bottom: 10px; position: relative; overflow: hidden; }
        .mini-card { position: absolute; width: 20px; height: 30px; background: var(--secondary-colour); border-radius: 2px; }
        .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
        
        .template-card.custom { background-color: #f0f3f5; }
        .delete-template-btn { position: absolute; top: 5px; right: 5px; width: 24px; height: 24px; border: none; background: #e74c3c; color: white; border-radius: 50%; cursor: pointer; font-size: 14px; line-height: 24px; text-align: center; opacity: 0; transition: opacity 0.2s ease; }
        .template-card:hover .delete-template-btn { opacity: 1; }
        .delete-template-btn:hover { background: #c0392b; }
        
        #cropModal .modal-content { max-width: 600px; } #imagePreviewContainer { text-align: center; margin-bottom: 20px; } #imageToProcess { max-width: 100%; max-height: 40vh; border: 1px solid #ddd; } #cropContainer { display: none; width: 100%; max-height: 50vh; margin-bottom: 20px; } #cropContainer img { display: block; max-width: 100%; } .crop-actions { text-align: right; }
        
        @media (max-width: 768px) { .spread-maker { grid-template-columns: 1fr; height: auto; } .controls-panel { order: 2; } .spread-canvas { height: 60vh; order: 1; } .card-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); } }
    </style>
</head>
<body>
    <div class="container"> <header> 
        <h1>å¡”ç½—ç‰Œé˜µè‡ªå®šä¹‰æ¨æ¼”å™¨</h1>
        <p class="subtitle">æ˜Ÿç½—å·¥ä½œå®¤ åˆ¶ä½œ</p>
    </header> <div class="tabs"> <button class="tab active" onclick="switchTab('maker')">ç‰Œé˜µåˆ¶ä½œ</button> <button class="tab" onclick="switchTab('info')">ç‰Œé¢ä¿¡æ¯</button> <button class="tab" onclick="switchTab('spreads')">å¸¸è§ç‰Œé˜µ</button> </div> <div id="maker" class="tab-content active"> <div class="spread-maker"> <div class="controls-panel"> <div class="control-section"> <h3>ç”»å¸ƒæ“ä½œ</h3> <button class="btn" onclick="showTemplates()">åŠ è½½æ¨¡æ¿</button> <button class="btn secondary" onclick="clearCanvas()">æ¸…ç©ºç”»å¸ƒ</button> <button class="btn secondary" onclick="resetView()">é‡ç½®è§†å›¾</button> <button class="btn danger" id="deleteSelectedButton" onclick="deleteSelectedElement()" disabled>åˆ é™¤é€‰ä¸­é¡¹</button> </div> <div class="control-section"> <h3>ç‰Œé˜µæ–‡ä»¶</h3> <input type="file" id="importSpreadInput" class="visually-hidden" accept=".json" onchange="handleImportSpread(event)"> <label for="importSpreadInput" class="btn">å¯¼å…¥ç‰Œé˜µ (JSON)</label> <button class="btn" onclick="saveSpread()">ä¿å­˜ç‰Œé˜µ (JSON)</button> <button class="btn" id="saveAsTemplateBtn" onclick="saveCurrentSpreadAsTemplate()" style="margin-top: 10px;">å°†å½“å‰å¸ƒå±€å­˜ä¸ºæ¨¡æ¿</button> </div> <div class="control-section"> <h3>æ·»åŠ ä½ç½®æ ‡è®°</h3> <label>ä½ç½®ç¼–å·ï¼š</label> <input type="number" id="positionNumber" min="1" max="20" value="1"> <label>ä½ç½®å«ä¹‰ï¼š</label> <input type="text" id="positionMeaning" placeholder="ä¾‹å¦‚ï¼šå½“å‰çŠ¶å†µ"> <button class="btn" onclick="addPosition()">æ·»åŠ ä½ç½®</button> </div> <div class="control-section"> <h3>é€‰æ‹©å¡”ç½—ç‰Œ</h3> <label>é€‰æ‹©ç‰Œé¢ï¼š</label> <select id="cardSelect"><option value="">è¯·é€‰æ‹©ä¸€å¼ ç‰Œ...</option></select> <label>æ—‹è½¬è§’åº¦ï¼š</label> <input type="number" id="rotation" min="0" max="360" value="0" step="15"> <label><input type="checkbox" id="reversed"> é€†ä½</label> <button class="btn" onclick="addCard()">æ·»åŠ ç‰Œé¢</button> </div> <div class="control-section"> <h3>è‡ªå®šä¹‰å›¾ç‰‡</h3> <input type="file" id="batchUploadInput" class="visually-hidden" accept="image/*" multiple onchange="handleBatchUpload(event)"> <label for="batchUploadInput" class="btn">æ‰¹é‡ä¸Šä¼ ç‰Œé¢</label> <button class="btn secondary" onclick="clearAllCustomImages()">æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰å›¾ç‰‡</button> <button class="btn danger" onclick="clearAllData()" style="margin-top: 10px;">æ¸…é™¤æ‰€æœ‰æ•°æ® (æ¢å¤å‡ºå‚)</button> </div><div class="control-section"> <h3>å¯¼å‡ºä¸ºå›¾ç‰‡</h3> <button class="btn secondary" onclick="exportImage()">å¯¼å‡ºä¸ºå›¾ç‰‡</button> <button class="btn secondary" onclick="copyAsImage()">å¤åˆ¶ä¸ºå›¾ç‰‡</button> </div> </div> <div class="spread-canvas" id="canvas-viewport"> <div id="world"></div> </div> </div> </div> <div id="info" class="tab-content"> <h2 style="text-align: center; margin-bottom: 20px; color: var(--secondary-colour);">å¤§é˜¿å°”å¡é‚£</h2> <div class="card-grid" id="majorArcana"></div> <h2 style="text-align: center; margin: 30px 0 20px 0; color: var(--secondary-colour);">å°é˜¿å°”å¡é‚£</h2> <div class="card-grid" id="minorArcana"></div> </div> <div id="spreads" class="tab-content"> <h2 style="text-align: center; margin-bottom: 20px; color: var(--secondary-colour);">å¸¸è§å¡”ç½—ç‰Œé˜µ</h2> <div class="spread-templates" id="commonSpreads"></div> </div> </div>
    <div id="templateModal" class="modal"> <div class="modal-content"> <span class="close-modal" onclick="closeModal('templateModal')">&times;</span> <h2>é€‰æ‹©ä¸€ä¸ªç‰Œé˜µæ¨¡æ¿</h2> <div class="spread-templates" id="templateList"></div> </div> </div>
    <div id="cardModal" class="modal"> <div class="modal-content"> <span class="close-modal" onclick="closeModal('cardModal')">&times;</span> <div id="cardDetail"></div> </div> </div>
    <div id="cropModal" class="modal"> <div class="modal-content"> <span class="close-modal" onclick="closeCropModal()">&times;</span> <h2>è°ƒæ•´å›¾ç‰‡</h2> <div id="imagePreviewContainer"> <p>è¯·é€‰æ‹©å¦‚ä½•å°†å›¾ç‰‡æ”¾å…¥å¡ç‰Œï¼š</p> <img id="imageToProcess" src="" alt="å›¾ç‰‡é¢„è§ˆ"> <div class="crop-actions" style="margin-top: 15px;"> <button class="btn" onclick="processFit()">é€‚åº”å¡ç‰Œ (ä¿ç•™å®Œæ•´å›¾ç‰‡)</button> <button class="btn" onclick="initCropper()">å¡«å……å¡ç‰Œ (è£å‰ªå›¾ç‰‡)</button> </div> </div> <div id="cropContainer"> <img id="imageToCrop" src="" alt="å¾…è£å‰ªå›¾ç‰‡"> </div> <div class="crop-actions" id="cropSaveActions" style="display: none;"> <button class="btn secondary" onclick="closeCropModal()">å–æ¶ˆ</button> <button class="btn" id="cropAndSaveButton">ç¡®è®¤è£å‰ª</button> </div> </div> </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script>
        const majorArcana = [{id:0,name:"æ„šè€…",engName:"The Fool",meaning:"æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§",reversed:"é²è½ï¼Œå†’é™©ï¼Œæ„šè ¢",customImageSrc:null},{id:1,name:"é­”æœ¯å¸ˆ",engName:"The Magician",meaning:"æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡",reversed:"æ“çºµï¼Œè®¡åˆ’ä¸å‘¨ï¼Œæœªå¼€å‘çš„æ‰èƒ½",customImageSrc:null},{id:2,name:"å¥³ç¥­å¸",engName:"The High Priestess",meaning:"ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œå¥³æ€§åŠ›é‡",reversed:"ç§˜å¯†ï¼Œä¸ç›´è§‰è„±èŠ‚ï¼Œé€€ç¼©",customImageSrc:null},{id:3,name:"å¥³çš‡",engName:"The Empress",meaning:"å¥³æ€§æ°”è´¨ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå¯Œè¶³",reversed:"åˆ›ä½œéšœç¢ï¼Œä¾èµ–ä»–äºº",customImageSrc:null},{id:4,name:"çš‡å¸",engName:"The Emperor",meaning:"æƒå¨ï¼Œå»ºç«‹ï¼Œç»“æ„",reversed:"æš´æ”¿ï¼Œåˆšæ€§ï¼Œå†·æ¼ ",customImageSrc:null},{id:5,name:"æ•™çš‡",engName:"The Hierophant",meaning:"ç²¾ç¥æ™ºæ…§ï¼Œå®—æ•™ä¿¡ä»°ï¼Œä¼ ç»Ÿ",reversed:"ä¸ªäººä¿¡ä»°ï¼Œè‡ªç”±ï¼ŒæŒ‘æˆ˜ç°çŠ¶",customImageSrc:null},{id:6,name:"æ‹äºº",engName:"The Lovers",meaning:"çˆ±æƒ…ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œä»·å€¼è§‚",reversed:"ä¸å’Œè°ï¼Œå¤±è¡¡ï¼Œä»·å€¼è§‚ä¸åˆ",customImageSrc:null},{id:7,name:"æˆ˜è½¦",engName:"The Chariot",meaning:"æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œå†³å¿ƒ",reversed:"ç¼ºä¹æ§åˆ¶ï¼Œç¼ºä¹æ–¹å‘ï¼Œä¾µç•¥æ€§",customImageSrc:null},{id:8,name:"åŠ›é‡",engName:"Strength",meaning:"å†…åœ¨åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè€å¿ƒï¼Œæ§åˆ¶",reversed:"è‡ªæˆ‘æ€€ç–‘ï¼Œè½¯å¼±ï¼Œä¸å®‰å…¨æ„Ÿ",customImageSrc:null},{id:9,name:"éšå£«",engName:"The Hermit",meaning:"çµé­‚æ¢ç´¢ï¼Œå†…çœï¼Œå†…åœ¨æŒ‡å¼•",reversed:"å­¤ç«‹ï¼Œå­¤ç‹¬ï¼Œé€€ç¼©",customImageSrc:null},{id:10,name:"å‘½è¿ä¹‹è½®",engName:"Wheel of Fortune",meaning:"å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿",reversed:"å„è¿ï¼Œç¼ºä¹æ§åˆ¶ï¼Œæ‰§ç€äºæ§åˆ¶",customImageSrc:null},{id:11,name:"æ­£ä¹‰",engName:"Justice",meaning:"å…¬æ­£ï¼Œå…¬å¹³ï¼ŒçœŸç›¸ï¼Œæ³•å¾‹",reversed:"ä¸å…¬ï¼Œç¼ºä¹è´£ä»»æ„Ÿï¼Œä¸è¯šå®",customImageSrc:null},{id:12,name:"å€’åŠäºº",engName:"The Hanged Man",meaning:"æš‚åœï¼Œé™åˆ¶ï¼Œæ”¾æ‰‹",reversed:"çŠ¹è±«ä¸å†³ï¼Œå»¶è¿Ÿï¼ŒæŠµæŠ—",customImageSrc:null},{id:13,name:"æ­»ç¥",engName:"Death",meaning:"ç»“æŸï¼Œå¼€å§‹ï¼Œæ”¹å˜ï¼Œè½¬å˜",reversed:"æŠ—æ‹’æ”¹å˜ï¼Œæ— æ³•å‰è¿›",customImageSrc:null},{id:14,name:"èŠ‚åˆ¶",engName:"Temperance",meaning:"å¹³è¡¡ï¼ŒèŠ‚åˆ¶ï¼Œè€å¿ƒï¼Œç›®çš„",reversed:"å¤±è¡¡ï¼Œè¿‡åº¦ï¼Œç¼ºä¹é•¿è¿œçœ¼å…‰",customImageSrc:null},{id:15,name:"æ¶é­”",engName:"The Devil",meaning:"æŸç¼šï¼Œä¸Šç˜¾ï¼Œæ€§æ¬²ï¼Œç‰©è´¨ä¸»ä¹‰",reversed:"é‡Šæ”¾é™åˆ¶æ€§ä¿¡å¿µï¼Œæ¢ç´¢é»‘æš—æƒ³æ³•",customImageSrc:null},{id:16,name:"é«˜å¡”",engName:"The Tower",meaning:"çªç„¶æ”¹å˜ï¼ŒåŠ¨è¡ï¼Œæ··ä¹±ï¼Œå¯ç¤º",reversed:"ä¸ªäººè½¬å˜ï¼Œææƒ§æ”¹å˜",customImageSrc:null},{id:17,name:"æ˜Ÿæ˜Ÿ",engName:"The Star",meaning:"å¸Œæœ›ï¼Œä¿¡ä»°ï¼Œç›®çš„ï¼Œæ›´æ–°ï¼Œçµæ€§",reversed:"ç¼ºä¹ä¿¡ä»°ï¼Œç»æœ›ï¼Œæ²®ä¸§",customImageSrc:null},{id:18,name:"æœˆäº®",engName:"The Moon",meaning:"å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†",reversed:"é‡Šæ”¾ææƒ§ï¼Œå‹æŠ‘çš„æƒ…ç»ªï¼Œå†…å¿ƒå›°æƒ‘",customImageSrc:null},{id:19,name:"å¤ªé˜³",engName:"The Sun",meaning:"å¿«ä¹ï¼ŒæˆåŠŸï¼Œåº†ç¥ï¼Œç§¯æ",reversed:"å†…åœ¨çš„å­©å­ï¼Œæ„Ÿåˆ°æ²®ä¸§",customImageSrc:null},{id:20,name:"å®¡åˆ¤",engName:"Judgement",meaning:"åæ€ï¼Œæ¸…ç®—ï¼Œå†…åœ¨å¬å”¤",reversed:"è‡ªæˆ‘æ€€ç–‘ï¼Œæ— æ³•åŸè°…",customImageSrc:null},{id:21,name:"ä¸–ç•Œ",engName:"The World",meaning:"å®Œæˆï¼Œæˆå°±ï¼Œæ—…è¡Œï¼Œç»Ÿä¸€",reversed:"æœªå®Œæˆï¼Œæ²¡æœ‰ç»“æŸ",customImageSrc:null}];
        const suits=["æƒæ–","åœ£æ¯","å®å‰‘","é‡‘å¸"],suitEngNames=["Wands","Cups","Swords","Pentacles"],courtCards=["ä¾ä»","éª‘å£«","ç‹å","å›½ç‹"],courtEngNames=["Page","Knight","Queen","King"],minorArcana=[];suits.forEach((a,b)=>{for(let c=1;c<=10;c++){let d=1===c?`${a}ç‹ç‰Œ`:`${a}${c}`,e=1===c?`Ace of ${suitEngNames[b]}`:`${c} of ${suitEngNames[b]}`;minorArcana.push({id:minorArcana.length+22,name:d,engName:e,suit:a,suitEng:suitEngNames[b],number:c,customImageSrc:null})}courtCards.forEach((c,d)=>{minorArcana.push({id:minorArcana.length+22,name:`${a}${c}`,engName:`${courtEngNames[d]} of ${suitEngNames[b]}`,suit:a,suitEng:suitEngNames[b],court:c,customImageSrc:null})})});const allCards=[...majorArcana,...minorArcana];
        const spreadTemplates={threeCard:{name:"ä¸‰ç‰Œé˜µ",positions:[{num:1,meaning:"è¿‡å»",x:4500,y:4800},{num:2,meaning:"ç°åœ¨",x:5000,y:4800},{num:3,meaning:"æœªæ¥",x:5500,y:4800}]},celticCross:{name:"å‡¯å°”ç‰¹åå­—",positions:[{num:1,meaning:"å½“å‰çŠ¶å†µ",x:4900,y:4800},{num:2,meaning:"æŒ‘æˆ˜/äº¤å‰",x:4900,y:4800,rotation:90},{num:3,meaning:"é¥è¿œçš„è¿‡å»",x:4900,y:5200},{num:4,meaning:"æœ€è¿‘çš„è¿‡å»",x:4500,y:4800},{num:5,meaning:"å¯èƒ½çš„æœªæ¥",x:4900,y:4400},{num:6,meaning:"è¿‘æœŸæœªæ¥",x:5300,y:4800},{num:7,meaning:"ä½ çš„æ€åº¦",x:5700,y:5300},{num:8,meaning:"å¤–éƒ¨å½±å“",x:5700,y:5000},{num:9,meaning:"å¸Œæœ›ä¸ææƒ§",x:5700,y:4700},{num:10,meaning:"ç»“æœ",x:5700,y:4400}]},horseshoe:{name:"é©¬è¹„é“ç‰Œé˜µ",positions:[{num:1,meaning:"è¿‡å»",x:4500,y:5200},{num:2,meaning:"ç°åœ¨",x:4800,y:4800},{num:3,meaning:"éšè—çš„å½±å“",x:5100,y:4600},{num:4,meaning:"éšœç¢",x:5400,y:4800},{num:5,meaning:"å»ºè®®",x:5700,y:5200}]}};
        
        let customSpreadTemplates = {};
        let isDraggingElement = false, isPanning = false;
        let draggedElement = null, dragStartElementPos = {x: 0, y: 0};
        let dragStartMousePos = {x: 0, y: 0};
        let cardPositions = [], placedCards = [];
        let selectedElementOnCanvas = null;
        const SNAP_GRID_SIZE = 30;
        let scale = 1.0, panX = 0, panY = 0;
        let cropper = null;
        let currentCardIdForCropping = null;
        let sourceImageForProcessing = null;
        const TAROT_CARD_WIDTH = 197;
        const TAROT_CARD_HEIGHT = 342;
        const TAROT_CARD_ASPECT_RATIO = TAROT_CARD_WIDTH / TAROT_CARD_HEIGHT;
        const DB_NAME = "tarotAppDB", DB_VERSION = 1, STORE_NAME = "customImages";
        let db;

        function initDB() { return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, DB_VERSION); request.onerror = event => reject("IndexedDB error: " + event.target.errorCode); request.onsuccess = event => { db = event.target.result; resolve(db); }; request.onupgradeneeded = event => { const db = event.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) { db.createObjectStore(STORE_NAME, { keyPath: 'id' }); } }; }); }
        function dbSet(data) { return new Promise((resolve, reject) => { if (!db) return reject("DB not initialized."); const transaction = db.transaction([STORE_NAME], 'readwrite'); const store = transaction.objectStore(STORE_NAME); const request = store.put(data); request.onsuccess = () => resolve(request.result); request.onerror = event => reject("DB set error: " + event.target.error); }); }
        function dbGetAll() { return new Promise((resolve, reject) => { if (!db) return reject("DB not initialized."); const transaction = db.transaction([STORE_NAME], 'readonly'); const store = transaction.objectStore(STORE_NAME); const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = event => reject("DB get all error: " + event.target.error); }); }
        function dbDelete(key) { return new Promise((resolve, reject) => { if (!db) return reject("DB not initialized."); const transaction = db.transaction([STORE_NAME], 'readwrite'); const store = transaction.objectStore(STORE_NAME); const request = store.delete(key); request.onsuccess = () => resolve(request.result); request.onerror = event => reject("DB delete error: " + event.target.error); }); }
        function dbClear() { return new Promise((resolve, reject) => { if (!db) return reject("DB not initialized."); const transaction = db.transaction([STORE_NAME], 'readwrite'); const store = transaction.objectStore(STORE_NAME); const request = store.clear(); request.onsuccess = () => resolve(request.result); request.onerror = event => reject("DB clear error: " + event.target.error); }); }

        window.onload = async function() {
            try { await initDB(); await loadCustomImages(); } catch(e) { console.error("Failed to initialize database:", e); alert("æ— æ³•åˆå§‹åŒ–æ•°æ®åº“ï¼Œè‡ªå®šä¹‰å›¾ç‰‡åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ã€‚"); }
            loadCustomTemplates(); populateCardSelect(); populateCardGrids(); populateCommonSpreads(); setupCanvasInteractions();
            document.getElementById('cropAndSaveButton').addEventListener('click', processCrop);
            document.addEventListener('click', function(e) { if (e.target && e.target.classList.contains('delete-template-btn')) { const templateName = e.target.dataset.templateName; deleteCustomTemplate(templateName); } });
            resetView();
        };

        async function loadCustomImages() { try { const images = await dbGetAll(); images.forEach(imgData => { const card = allCards.find(c => c.id === imgData.id); if (card) { card.customImageSrc = URL.createObjectURL(imgData.imageBlob); } }); } catch (e) { console.error("Failed to load images from DB:", e); } }
        async function saveCustomImage(cardId, imageBlob) { const card = allCards.find(c => c.id === cardId); if (!card) return false; try { await dbSet({ id: cardId, imageBlob: imageBlob }); if (card.customImageSrc && card.customImageSrc.startsWith('blob:')) { URL.revokeObjectURL(card.customImageSrc); } card.customImageSrc = URL.createObjectURL(imageBlob); return true; } catch (e) { console.error("Failed to save image to DB:", e); alert("ä¿å­˜å›¾ç‰‡å¤±è´¥ï¼è¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚"); return false; } }
        function processFit() { if (!sourceImageForProcessing || currentCardIdForCropping === null) return; generateFittedImage(sourceImageForProcessing, 'blob').then(async (imageBlob) => { if (await saveCustomImage(currentCardIdForCropping, imageBlob)) { updateUIAfterSave(currentCardIdForCropping); } closeCropModal(); }); }
        async function handleBatchUpload(event) { const files = event.target.files; if (!files.length) return; const confirmed = confirm( "æ‰¹é‡ä¸Šä¼ è¯´æ˜ï¼š\n\n" + "è¯·ç¡®ä¿æ‚¨çš„å›¾ç‰‡æ–‡ä»¶åä»¥å¡ç‰Œçš„IDå‘½åï¼Œä¾‹å¦‚ '0.png', '22.jpg' ç­‰ã€‚\n" + "ç¨‹åºå°†è‡ªåŠ¨åŒ¹é…IDå¹¶æ›´æ–°ç‰Œé¢ã€‚å‘½åä¸æ­£ç¡®çš„æ–‡ä»¶å°†è¢«å¿½ç•¥ã€‚\n\n" + "æ˜¯å¦ç»§ç»­ï¼Ÿ" ); if (!confirmed) { event.target.value = null; return; } let successCount = 0; const failedFiles = []; for (const file of files) { const fileName = file.name; const cardId = parseInt(fileName.split('.')[0], 10); if (isNaN(cardId) || !allCards.find(c => c.id === cardId)) { failedFiles.push(fileName); continue; } try { const fittedImageBlob = await generateFittedImage(file, 'blob'); if (await saveCustomImage(cardId, fittedImageBlob)) { successCount++; } else { failedFiles.push(fileName); } } catch (error) { console.error("Error processing file:", fileName, error); failedFiles.push(fileName); } } populateCardGrids(); updateAllCardsOnCanvas(); let reportMessage = `æ‰¹é‡ä¸Šä¼ å®Œæˆï¼\n\næˆåŠŸæ›´æ–° ${successCount} å¼ å¡ç‰Œã€‚`; if (failedFiles.length > 0) { reportMessage += `\n\nå…± ${failedFiles.length} ä¸ªæ–‡ä»¶å¤„ç†å¤±è´¥æˆ–è¢«è·³è¿‡ã€‚è¯·æ£€æŸ¥å‘½åã€‚`; } alert(reportMessage); event.target.value = null; }
        function generateFittedImage(imageSource, outputType = 'blob') { return new Promise((resolve, reject) => { const img = new Image(); img.onload = () => { const canvas = document.createElement('canvas'); canvas.width = TAROT_CARD_WIDTH; canvas.height = TAROT_CARD_HEIGHT; const ctx = canvas.getContext('2d'); const hRatio = canvas.width / img.width; const vRatio = canvas.height / img.height; const ratio = Math.min(hRatio, vRatio); const centerX = (canvas.width - img.width * ratio) / 2; const centerY = (canvas.height - img.height * ratio) / 2; ctx.drawImage(img, 0, 0, img.width, img.height, centerX, centerY, img.width * ratio, img.height * ratio); if (outputType === 'blob') { canvas.toBlob(blob => resolve(blob), 'image/png'); } else { resolve(canvas.toDataURL('image/png')); } }; img.onerror = reject; if (typeof imageSource === 'string') { img.src = imageSource; } else { img.src = URL.createObjectURL(imageSource); } }); }
        function processCrop() { if (!cropper || currentCardIdForCropping === null) return; const canvas = cropper.getCroppedCanvas({ width: TAROT_CARD_WIDTH * 2, height: TAROT_CARD_HEIGHT * 2, imageSmoothingEnabled: true, imageSmoothingQuality: 'high' }); canvas.toBlob(async (blob) => { if (await saveCustomImage(currentCardIdForCropping, blob)) { updateUIAfterSave(currentCardIdForCropping); } closeCropModal(); }, 'image/png'); }
        async function clearCustomImage(cardId) { const card = allCards.find(c => c.id === cardId); if (card) { try { await dbDelete(cardId); if (card.customImageSrc && card.customImageSrc.startsWith('blob:')) { URL.revokeObjectURL(card.customImageSrc); } card.customImageSrc = null; updateUIAfterSave(cardId); } catch (e) { console.error("Failed to delete image from DB:", e); } } }
        async function clearAllCustomImages() { if (!confirm("ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰å¡”ç½—ç‰Œå›¾ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚")) return; try { await dbClear(); allCards.forEach(card => { if (card.customImageSrc && card.customImageSrc.startsWith('blob:')) { URL.revokeObjectURL(card.customImageSrc); } card.customImageSrc = null; }); populateCardGrids(); updateAllCardsOnCanvas(); alert("æ‰€æœ‰è‡ªå®šä¹‰å›¾ç‰‡å·²æ¸…é™¤ã€‚"); } catch(e) { alert("æ¸…é™¤å›¾ç‰‡å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚"); } }
        async function clearAllData() { if (!confirm("è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰å·²ä¿å­˜çš„è‡ªå®šä¹‰ç‰Œé¢å’Œè‡ªå®šä¹‰ç‰Œé˜µæ¨¡æ¿ï¼Œä¸”æ— æ³•æ¢å¤ï¼\n\næ‚¨ç¡®å®šè¦æ¢å¤å‡ºå‚è®¾ç½®å—ï¼Ÿ")) return; await clearAllCustomImages(); customSpreadTemplates = {}; localStorage.removeItem('customTarotSpreads'); populateAllTemplateLists(); alert("æ‰€æœ‰è‡ªå®šä¹‰æ•°æ®å·²æ¸…é™¤ã€‚åº”ç”¨å·²æ¢å¤è‡³åˆå§‹çŠ¶æ€ã€‚"); }
        function updateUIAfterSave(cardId) { const imgElement = document.getElementById(`card-img-${cardId}`); const card = allCards.find(c => c.id === cardId); if (imgElement && card) { imgElement.src = card.customImageSrc || `data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(card))}`; } const cardItemElement = document.getElementById(`card-item-${cardId}`); const parentGrid = cardItemElement.parentNode; if(cardItemElement && parentGrid) parentGrid.replaceChild(createCardDisplay(card), cardItemElement); updateAllCardsOnCanvas(); }
        
        function updateWorldTransform(){document.getElementById("world").style.transform=`translate(${panX}px, ${panY}px) scale(${scale})`}function initCropper(){sourceImageForProcessing&&(document.getElementById("imagePreviewContainer").style.display="none",document.getElementById("cropContainer").style.display="block",document.getElementById("cropSaveActions").style.display="block",imageToCropElement=document.getElementById("imageToCrop"),imageToCropElement.src=sourceImageForProcessing,cropper&&cropper.destroy(),cropper=new Cropper(imageToCropElement,{aspectRatio:TAROT_CARD_ASPECT_RATIO,viewMode:1,dragMode:"move",background:!1,autoCropArea:1,responsive:!0,checkCrossOrigin:!1}))}function closeCropModal(){cropper&&(cropper.destroy(),cropper=null),document.getElementById("cropModal").style.display="none",currentCardIdForCropping=null,sourceImageForProcessing=null}
        function updateAllCardsOnCanvas(){placedCards.forEach(a=>{const b=allCards.find(c=>c.id===a.card.id);if(b){const c=a.element.querySelector(".card-image");c&&(c.src=b.customImageSrc||`data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(b))}`)}})}function switchTab(a){document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active")),document.querySelectorAll(".tab-content").forEach(b=>b.classList.remove("active")),event.target.classList.add("active"),document.getElementById(a).classList.add("active")}function populateCardSelect(){const a=document.getElementById("cardSelect");a.innerHTML='<option value="">è¯·é€‰æ‹©ä¸€å¼ ç‰Œ...</option>';const b=document.createElement("optgroup");b.label="å¤§é˜¿å°”å¡é‚£",majorArcana.forEach(c=>{const d=document.createElement("option");d.value=c.id,d.textContent=`${c.id}. ${c.name}`,b.appendChild(d)}),a.appendChild(b),suits.forEach(c=>{const d=document.createElement("optgroup");d.label=c,minorArcana.filter(e=>e.suit===c).forEach(e=>{const f=document.createElement("option");f.value=e.id,f.textContent=e.name,d.appendChild(f)}),a.appendChild(d)})}function populateCardGrids(){const a=document.getElementById("majorArcana"),b=document.getElementById("minorArcana");a.innerHTML="",b.innerHTML="",majorArcana.forEach(c=>a.appendChild(createCardDisplay(c))),minorArcana.forEach(c=>b.appendChild(createCardDisplay(c)))}
        function createCardDisplay(a){const b=document.createElement("div");b.className="card-item",b.id=`card-item-${a.id}`;const c=document.createElement("div");c.className="image-container",c.onclick=()=>showCardDetail(a);const d=document.createElement("img");d.src=a.customImageSrc||`data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(a))}`,d.alt=a.name,d.id=`card-img-${a.id}`,c.appendChild(d);const e=document.createElement("h4");e.textContent=a.name;const f=document.createElement("div");f.className="upload-actions";const g=`file-input-${a.id}`,h=document.createElement("input");h.type="file",h.accept="image/*",h.className="visually-hidden",h.id=g,h.onchange=i=>handleImageUpload(i,a.id);const j=document.createElement("label");return j.htmlFor=g,j.className="btn btn-small",j.textContent="ä¸Šä¼ å›¾ç‰‡",f.appendChild(h),f.appendChild(j),a.customImageSrc&&(k=document.createElement("button"),k.className="btn btn-small secondary",k.textContent="æ¸…é™¤å›¾ç‰‡",k.onclick=()=>clearCustomImage(a.id),f.appendChild(k)),b.appendChild(c),b.appendChild(e),b.appendChild(f),b}
        function generateDetailedCardSVG(a){const b=22<=a.id,c=b?getSuitColor(a.suitEng||a.suit):"#2c3e50",d={0:"â˜‰",1:"ğŸƒ",2:"â˜½",3:"â™€",4:"â™‚",5:"âœš",6:"â™¥",7:"â˜¸",8:"â™Œ",9:"ë¨",10:"â˜¯",11:"âš–",12:"âŠ¥",13:"â˜ ",14:"â˜®",15:"â›¤",16:"âš¡",17:"âœ¦",18:"â˜½",19:"â˜‰",20:"âœ ",21:"âŠ•"},e={Wands:"ğŸ”¥",Cups:"ğŸ’§",Swords:"âš”ï¸",Pentacles:"â­"};let f=`<svg width="197" height="342" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="gradSVG${a.id}" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:${c};stop-opacity:0.8" /><stop offset="100%" style="stop-color:${c};stop-opacity:1" /></linearGradient></defs><rect width="197" height="342" fill="url(#gradSVG${a.id})" rx="8"/><rect x="5" y="5" width="187" height="332" fill="none" stroke="white" stroke-width="2" rx="4"/>`;return b?(()=>{const b=e[a.suitEng]||"â™¦";a.number?f+=`<text x="98.5" y="60" text-anchor="middle" fill="white" font-size="48" font-weight="bold">${getRomanNumeral(a.number)}</text><text x="98.5" y="171" text-anchor="middle" fill="white" font-size="60">${b}</text><text x="98.5" y="280" text-anchor="middle" fill="white" font-size="24">${a.name}</text>`:f+=`<text x="98.5" y="60" text-anchor="middle" fill="white" font-size="32" font-weight="bold">${a.court}</text><text x="98.5" y="171" text-anchor="middle" fill="white" font-size="60">${b}</text><text x="98.5" y="280" text-anchor="middle" fill="white" font-size="24">${a.suit}</text>`})():f+=`<text x="98.5" y="40" text-anchor="middle" fill="white" font-size="24" font-weight="bold">${a.id}</text><text x="98.5" y="171" text-anchor="middle" fill="white" font-size="80">${d[a.id]||"âœ¦"}</text><text x="98.5" y="280" text-anchor="middle" fill="white" font-size="28" font-weight="bold">${a.name}</text>`,f+="</svg>",f}
        function getSuitColor(a){const b={Wands:"#d35400",æƒæ–:"#d35400",Cups:"#3498db",åœ£æ¯:"#3498db",Swords:"#7f8c8d",å®å‰‘:"#7f8c8d",Pentacles:"#27ae60",é‡‘å¸:"#27ae60"};return b[a]||"#2c3e50"}function getRomanNumeral(a){const b=["","I","II","III","IV","V","VI","VII","VIII","IX","X"];return b[a]||a}
        function addElementToWorld(a){const b=document.getElementById("canvas-viewport"),c=document.getElementById("world"),d=b.clientWidth/2,e=b.clientHeight/2,f=(d-panX)/scale,g=(e-panY)/scale;a.style.left=`${f-a.clientWidth/2}px`,a.style.top=`${g-a.clientHeight/2}px`,makeDraggable(a),c.appendChild(a),selectCanvasElement(a)}function addPosition(){const a=document.getElementById("positionNumber").value,b=document.getElementById("positionMeaning").value;if(!b)return void alert("è¯·è¾“å…¥ä½ç½®å«ä¹‰");const c=document.createElement("div");c.className="position-marker",c.innerHTML=`${a}: ${b}`,c.dataset.positionNum=a,c.dataset.meaning=b,cardPositions.push({number:a,meaning:b,element:c}),addElementToWorld(c)}
        function addCard(){const a=document.getElementById("cardSelect").value;if(!a)return void alert("è¯·é€‰æ‹©ä¸€å¼ ç‰Œ");const b=document.getElementById("rotation").value,c=document.getElementById("reversed").checked,d=allCards.find(f=>f.id==a),e=document.createElement("div");e.className="tarot-card";let g=parseInt(b)||0;c&&(g+=180),e.style.transform=`rotate(${g}deg)`,e.dataset.cardId=a,e.dataset.baseRotation=b,e.dataset.reversed=c;const h=document.createElement("img");h.className="card-image",h.src=d.customImageSrc||`data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(d))}`,h.alt=d.name,e.appendChild(h),placedCards.push({card:d,element:e,rotation:b,reversed:c}),addElementToWorld(e)}
        function makeDraggable(a){a.addEventListener("mousedown",onElementMouseDown),a.addEventListener("touchstart",onElementMouseDown,{passive:!1})}function selectCanvasElement(a){selectedElementOnCanvas&&selectedElementOnCanvas.classList.remove("selected"),selectedElementOnCanvas=a,selectedElementOnCanvas?(selectedElementOnCanvas.classList.add("selected"),document.getElementById("deleteSelectedButton").disabled=!1):document.getElementById("deleteSelectedButton").disabled=!0}function deselectCanvasElement(){selectedElementOnCanvas&&(selectedElementOnCanvas.classList.remove("selected"),selectedElementOnCanvas=null,document.getElementById("deleteSelectedButton").disabled=!0)}
        function deleteSelectedElement(){selectedElementOnCanvas&&(selectedElementOnCanvas.classList.contains("tarot-card")?placedCards=placedCards.filter(a=>a.element!==selectedElementOnCanvas):selectedElementOnCanvas.classList.contains("position-marker")&&(cardPositions=cardPositions.filter(a=>a.element!==selectedElementOnCanvas)),selectedElementOnCanvas.remove(),deselectCanvasElement())}function setupCanvasInteractions(){const a=document.getElementById("canvas-viewport");a.addEventListener("mousedown",onViewportMouseDown),a.addEventListener("wheel",onWheel,{passive:!1}),document.addEventListener("keydown",b=>{("Delete"===b.key||"Backspace"===b.key)&&selectedElementOnCanvas&&"INPUT"!==document.activeElement.tagName&&"TEXTAREA"!==document.activeElement.tagName&&(b.preventDefault(),deleteSelectedElement())})}
        function onElementMouseDown(a){a.stopPropagation(),isDraggingElement=!0,isPanning=!1,draggedElement=a.currentTarget,selectCanvasElement(draggedElement);const b=a.touches?a.touches[0]:a;dragStartMousePos={x:b.clientX,y:b.clientY},dragStartElementPos={x:parseFloat(draggedElement.style.left)||0,y:parseFloat(draggedElement.style.top)||0},document.addEventListener("mousemove",onDocumentMouseMove),document.addEventListener("mouseup",onDocumentMouseUp),document.addEventListener("touchmove",onDocumentMouseMove,{passive:!1}),document.addEventListener("touchend",onDocumentMouseUp)}
        function onViewportMouseDown(a){("world"===a.target.id||"canvas-viewport"===a.target.id)&&(isPanning=!0,isDraggingElement=!1,dragStartMousePos={x:(a.touches?a.touches[0]:a).clientX,y:(a.touches?a.touches[0]:a).clientY},document.getElementById("canvas-viewport").classList.add("panning"),deselectCanvasElement(),document.addEventListener("mousemove",onDocumentMouseMove),document.addEventListener("mouseup",onDocumentMouseUp),document.addEventListener("touchmove",onDocumentMouseMove,{passive:!1}),document.addEventListener("touchend",onDocumentMouseUp))}
        function onDocumentMouseMove(a){const b=a.touches?a.touches[0]:a,c=b.clientX-dragStartMousePos.x,d=b.clientY-dragStartMousePos.y;if(isPanning)panX+=c,panY+=d,dragStartMousePos={x:b.clientX,y:b.clientY},updateWorldTransform();else if(isDraggingElement){draggedElement.classList.add("dragging");let e=dragStartElementPos.x+c/scale,f=dragStartElementPos.y+d/scale;e=Math.round(e/SNAP_GRID_SIZE)*SNAP_GRID_SIZE,f=Math.round(f/SNAP_GRID_SIZE)*SNAP_GRID_SIZE,draggedElement.style.left=`${e}px`,draggedElement.style.top=`${f}px`}}
        function onDocumentMouseUp(){isDraggingElement&&draggedElement.classList.remove("dragging"),isPanning&&document.getElementById("canvas-viewport").classList.remove("panning"),isDraggingElement=!1,isPanning=!1,draggedElement=null,document.removeEventListener("mousemove",onDocumentMouseMove),document.removeEventListener("mouseup",onDocumentMouseUp),document.removeEventListener("touchmove",onDocumentMouseMove),document.removeEventListener("touchend",onDocumentMouseUp)}
        function onWheel(a){a.preventDefault();const b=document.getElementById("canvas-viewport"),c=b.getBoundingClientRect(),d=a.clientX-c.left,e=a.clientY-c.top,f=(d-panX)/scale,g=(e-panY)/scale;let h=0>a.deltaY?Math.min(2,1.1*scale):Math.max(.1,scale/1.1);panX=d-f*h,panY=e-g*h,scale=h,updateWorldTransform()}
        function populateAllTemplateLists(){populateTemplateList(document.getElementById("commonSpreads")),populateTemplateList(document.getElementById("templateList"))}
        function populateTemplateList(a){a.innerHTML="";const b={...spreadTemplates,...customSpreadTemplates};Object.values(b).forEach(c=>{const d=customSpreadTemplates.hasOwnProperty(c.name),e=document.createElement("div");e.className=`template-card ${d?"custom":""}`,e.onclick=f=>{f.target.classList.contains("delete-template-btn")||(loadTemplate(c),"templateList"===a.id&&closeModal("templateModal"))};const f=document.createElement("div");f.className="template-preview",c.positions.forEach(g=>{const h=document.createElement("div");h.className="mini-card",h.style.left=`${(g.x-4e3)/20}%`,h.style.top=`${(g.y-4e3)/20}%`,h.style.transform=`translate(-50%, -50%) rotate(${g.rotation||0}deg)`,f.appendChild(h)});const i=document.createElement("h3");i.textContent=c.name,e.appendChild(f),e.appendChild(i),d&&(j=document.createElement("button"),j.className="delete-template-btn",j.innerHTML="&times;",j.dataset.templateName=c.name,j.title=`åˆ é™¤æ¨¡æ¿ "${c.name}"`,e.appendChild(j)),a.appendChild(e)})}
        function populateCommonSpreads(){populateTemplateList(document.getElementById("commonSpreads"))}
        function showTemplates(){document.getElementById("templateModal").style.display="block",populateTemplateList(document.getElementById("templateList"))}
        
        // --- FIX: Loading a template no longer clears the canvas ---
        function loadTemplate(a){
            const b=document.getElementById("world");
            a.positions.forEach(c=>{
                const d=document.createElement("div");
                d.className="position-marker",
                d.style.left=`${c.x}px`,
                d.style.top=`${c.y}px`,
                d.style.transform=`rotate(${c.rotation||0}deg)`,
                d.innerHTML=`${c.num}: ${c.meaning}`,
                d.dataset.positionNum=c.num,
                d.dataset.meaning=c.meaning,
                makeDraggable(d),
                b.appendChild(d),
                cardPositions.push({number:c.num,meaning:c.meaning,element:d})
            });
            resetView()
        }
        
        function clearCanvas(){document.getElementById("world").innerHTML="",cardPositions=[],placedCards=[],deselectCanvasElement()}function closeModal(a){a&&document.getElementById(a)&&(document.getElementById(a).style.display="none"),"cropModal"===a&&cropper&&closeCropModal()}
        function showCardDetail(a){const b=document.getElementById("cardModal"),c=document.getElementById("cardDetail"),d=allCards.find(e=>e.id===a.id);c.innerHTML=`<h2>${d.name} ${d.engName?`(${d.engName})`:""}</h2><div style="text-align: center; margin: 20px 0;"><img src="${d.customImageSrc||`data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(d))}`}" style="width: 200px; height: 300px; border-radius: 8px; box-shadow: var(--card-shadow); object-fit: cover;"></div>${d.meaning?`<h3>æ­£ä½å«ä¹‰</h3><p>${d.meaning}</p><h3>é€†ä½å«ä¹‰</h3><p>${d.reversed||"ä¸æ­£ä½å«ä¹‰ç›¸åæˆ–èƒ½é‡å—é˜»"}</p>`:`<h3>ç‰Œé¢ä¿¡æ¯</h3><p>èŠ±è‰²ï¼š${d.suit}</p>${d.number?`<p>æ•°å­—ï¼š${d.number}</p>`:""}${d.court?`<p>å®«å»·ç‰Œï¼š${d.court}</p>`:""}`}`,b.style.display="block"}
        function saveSpread(){const a={positions:cardPositions.map(b=>({number:b.number,meaning:b.meaning,x:parseFloat(b.element.style.left),y:parseFloat(b.element.style.top),transform:b.element.style.transform})),cards:placedCards.map(b=>({cardId:b.card.id,cardName:b.card.name,x:parseFloat(b.element.style.left),y:parseFloat(b.element.style.top),transform:b.element.style.transform}))},b=JSON.stringify(a,null,2),c=new Blob([b],{type:"application/json"}),d=URL.createObjectURL(c),e=document.createElement("a");e.href=d,e.download=`å¡”ç½—ç‰Œé˜µ-${(new Date).toISOString().slice(0,10)}.json`,e.click(),URL.revokeObjectURL(d)}
        function handleImportSpread(a){const b=a.target.files[0];if(b){const c=new FileReader;c.onload=function(d){try{const e=JSON.parse(d.target.result);e&&(Array.isArray(e.positions)||Array.isArray(e.cards))?loadSpreadFromData(e):alert("å¯¼å…¥å¤±è´¥ï¼šJSONæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®æˆ–ç¼ºå°‘å¿…è¦æ•°æ®ã€‚")}catch(e){console.error("å¯¼å…¥ç‰Œé˜µé”™è¯¯:",e),alert("å¯¼å…¥å¤±è´¥ï¼šæ— æ³•è§£æJSONæ–‡ä»¶ã€‚ "+e.message)}},c.readAsText(b),a.target.value=null}}
        function loadSpreadFromData(a){clearCanvas();const b=document.getElementById("world");a.positions&&Array.isArray(a.positions)&&a.positions.forEach(c=>{const d=document.createElement("div");d.className="position-marker",d.style.left=`${c.x}px`||"4950px",d.style.top=`${c.y}px`||"4950px",d.style.transform=c.transform||"",d.innerHTML=`${c.number||"?"}: ${c.meaning||"æœªå®šä¹‰"}`,d.dataset.positionNum=c.number||"?",d.dataset.meaning=c.meaning||"æœªå®šä¹‰",makeDraggable(d),b.appendChild(d),cardPositions.push({number:c.number,meaning:c.meaning,element:d})}),a.cards&&Array.isArray(a.cards)&&a.cards.forEach(c=>{const d=allCards.find(f=>f.id==c.cardId);if(d){const e=document.createElement("div");e.className="tarot-card",e.style.left=`${c.x}px`||"4950px",e.style.top=`${c.y}px`||"4950px",e.style.transform=c.transform||"",e.dataset.cardId=d.id;const g=document.createElement("img");g.className="card-image",g.src=d.customImageSrc||`data:image/svg+xml,${encodeURIComponent(generateDetailedCardSVG(d))}`,g.alt=d.name,e.appendChild(g),makeDraggable(e),b.appendChild(e),placedCards.push({card:d,element:e})}else console.warn(`æœªæ‰¾åˆ°IDä¸º ${c.cardId} çš„å¡ç‰‡æ•°æ®`)}),resetView(),alert("ç‰Œé˜µå·²æˆåŠŸå¯¼å…¥ï¼")}
        
        function resetView() {
            const allElements = [...cardPositions.map(p => p.element), ...placedCards.map(c => c.element)];
            if (allElements.length === 0) {
                scale = 1.0;
                const viewport = document.getElementById("canvas-viewport");
                const viewportRect = viewport.getBoundingClientRect();
                panX = viewportRect.width / 2 - 5000;
                panY = viewportRect.height / 2 - 5000;
                updateWorldTransform();
                return;
            }
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allElements.forEach(el => {
                const left = parseFloat(el.style.left);
                const top = parseFloat(el.style.top);
                const width = el.offsetWidth;
                const height = el.offsetHeight;
                minX = Math.min(minX, left);
                minY = Math.min(minY, top);
                maxX = Math.max(maxX, left + width);
                maxY = Math.max(maxY, top + height);
            });
            const padding = 100;
            minX -= padding; minY -= padding; maxX += padding; maxY += padding;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const boundingWidth = maxX - minX;
            const boundingHeight = maxY - minY;
            const viewport = document.getElementById("canvas-viewport");
            const viewportRect = viewport.getBoundingClientRect();
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;
            const scaleX = viewportWidth / boundingWidth;
            const scaleY = viewportHeight / boundingHeight;
            scale = Math.min(scaleX, scaleY, 1.5);
            scale = Math.max(scale, 0.1);
            panX = viewportWidth / 2 - centerX * scale;
            panY = viewportHeight / 2 - centerY * scale;
            updateWorldTransform();
        }

        function handleImageUpload(event, cardId) {
            const file = event.target.files[0];
            if (!file) return;
            sourceImageForProcessing = URL.createObjectURL(file);
            currentCardIdForCropping = cardId;
            document.getElementById('imageToProcess').src = sourceImageForProcessing;
            document.getElementById('cropModal').style.display = 'block';
            event.target.value = null;
        }
        
        // --- FIX: Reworked export functions for reliability ---
        function getElementsBoundingBox() {
            const allElements = [...cardPositions.map(p => p.element), ...placedCards.map(c => c.element)];
            if (allElements.length === 0) return null;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allElements.forEach(el => {
                const left = parseFloat(el.style.left);
                const top = parseFloat(el.style.top);
                const width = el.offsetWidth;
                const height = el.offsetHeight;
                minX = Math.min(minX, left);
                minY = Math.min(minY, top);
                maxX = Math.max(maxX, left + width);
                maxY = Math.max(maxY, top + height);
            });
            const padding = 50;
            return {
                x: minX - padding,
                y: minY - padding,
                width: (maxX - minX) + (padding * 2),
                height: (maxY - minY) + (padding * 2)
            };
        }

        async function renderSpreadToCanvas() {
            deselectCanvasElement(); 
            const world = document.getElementById('world');
            const bounds = getElementsBoundingBox();
            if (!bounds) {
                alert("ç”»å¸ƒä¸Šæ²¡æœ‰å†…å®¹å¯å¯¼å‡ºã€‚");
                return null; 
            }

            const renderContainer = document.createElement('div');
            renderContainer.style.position = 'absolute';
            renderContainer.style.left = '-9999px'; 
            renderContainer.style.top = '-9999px';
            renderContainer.style.width = `${bounds.width}px`;
            renderContainer.style.height = `${bounds.height}px`;
            renderContainer.style.backgroundColor = '#fdfdfa';
            renderContainer.style.backgroundImage = `linear-gradient(rgba(139, 115, 85, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(139, 115, 85, 0.1) 1px, transparent 1px)`;
            renderContainer.style.backgroundSize = `30px 30px`;
            renderContainer.style.backgroundPosition = `-${bounds.x % 30}px -${bounds.y % 30}px`;

            Array.from(world.children).forEach(child => {
                if (child.classList.contains('tarot-card') || child.classList.contains('position-marker')) {
                    const clone = child.cloneNode(true);
                    const originalLeft = parseFloat(child.style.left) || 0;
                    const originalTop = parseFloat(child.style.top) || 0;
                    clone.style.left = `${originalLeft - bounds.x}px`;
                    clone.style.top = `${originalTop - bounds.y}px`;
                    clone.classList.remove('selected');
                    renderContainer.appendChild(clone);
                }
            });

            const watermark = document.createElement('div');
            watermark.textContent = "æ˜Ÿç½—";
            watermark.style.position = 'absolute';
            watermark.style.right = '20px';
            watermark.style.bottom = '20px';
            watermark.style.color = 'rgba(0, 0, 0, 0.2)';
            watermark.style.fontSize = '32px';
            watermark.style.fontWeight = 'bold';
            watermark.style.fontFamily = 'Microsoft YaHei, sans-serif';
            watermark.style.textShadow = '1px 1px 2px rgba(255,255,255,0.3)';
            watermark.style.pointerEvents = 'none';
            renderContainer.appendChild(watermark);

            document.body.appendChild(renderContainer);
            let canvas = null;
            try {
                canvas = await html2canvas(renderContainer, {
                    backgroundColor: null, 
                    scale: 2,
                    logging: false,
                    useCORS: true
                });
            } catch (err) {
                console.error("html2canvas failed:", err);
                alert("ç”Ÿæˆå›¾ç‰‡å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚");
            } finally {
                document.body.removeChild(renderContainer);
            }
            return canvas;
        }

        async function exportImage() {
            const canvas = await renderSpreadToCanvas();
            if (!canvas) return;
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `å¡”ç½—ç‰Œé˜µ-${(new Date).toISOString().slice(0,10)}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        async function copyAsImage() {
            const canvas = await renderSpreadToCanvas();
            if (!canvas) return;
            try {
                canvas.toBlob(async blob => {
                    try {
                        await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
                        alert("ç‰Œé˜µå·²å¤åˆ¶ä¸ºå›¾ç‰‡ï¼");
                    } catch (err) {
                        console.error("å¤åˆ¶å¤±è´¥ï¼š", err);
                        const dataUrl = canvas.toDataURL();
                        const modal = document.createElement('div');
                        modal.style.cssText = "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); z-index: 3000; max-width: 90%; max-height: 90vh; overflow: auto;";
                        modal.innerHTML = `<h3>å³é”®ç‚¹å‡»å›¾ç‰‡å¹¶é€‰æ‹©"å¤åˆ¶å›¾ç‰‡"</h3><div style="margin-top: 10px;"><img src="${dataUrl}" style="max-width: 100%; border: 1px solid #ddd;"></div><button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 10px 20px; background: #d4af37; color: white; border: none; border-radius: 5px; cursor: pointer;">å…³é—­</button>`;
                        document.body.appendChild(modal);
                    }
                }, 'image/png');
            } catch (e) {
                console.error("ç”Ÿæˆå›¾ç‰‡blobå¤±è´¥ï¼š", e);
                alert("å¤åˆ¶å›¾ç‰‡å¤±è´¥ï¼Œè¯·å°è¯•ä½¿ç”¨\"å¯¼å‡ºä¸ºå›¾ç‰‡\"åŠŸèƒ½");
            }
        }

        window.onclick=function(a){a.target.classList.contains("modal")&&closeModal(a.target.id)};
        function loadCustomTemplates(){const a=localStorage.getItem("customTarotSpreads");a&&Object.assign(customSpreadTemplates,JSON.parse(a))}
        function saveCurrentSpreadAsTemplate(){if(0===cardPositions.length)return void alert("ç”»å¸ƒä¸Šæ²¡æœ‰ä½ç½®æ ‡è®°ï¼Œæ— æ³•ä¿å­˜ä¸ºç©ºæ¨¡æ¿ã€‚");let a=prompt("è¯·ä¸ºæ‚¨çš„ç‰Œé˜µæ¨¡æ¿å‘½å:","æˆ‘çš„è‡ªå®šä¹‰ç‰Œé˜µ");if(a&&(a=a.trim())){if(!a)return void alert("æ¨¡æ¿åç§°ä¸èƒ½ä¸ºç©ºï¼");if((spreadTemplates[a]||customSpreadTemplates[a])&&!confirm(`åä¸º "${a}" çš„æ¨¡æ¿å·²å­˜åœ¨ã€‚æ‚¨æƒ³è¦†ç›–å®ƒå—ï¼Ÿ`))return;const b={name:a,positions:cardPositions.map(c=>({num:c.number,meaning:c.meaning,x:parseFloat(c.element.style.left),y:parseFloat(c.element.style.top),rotation:(c.element.style.transform.match(/rotate\(([^)]+)\)/)||["","0deg"])[1].replace("deg","")}))};customSpreadTemplates[a]=b;try{localStorage.setItem("customTarotSpreads",JSON.stringify(customSpreadTemplates)),alert(`æ¨¡æ¿ "${a}" å·²æˆåŠŸä¿å­˜ï¼`),populateAllTemplateLists()}catch(c){alert("ä¿å­˜æ¨¡æ¿å¤±è´¥ï¼æµè§ˆå™¨å­˜å‚¨ç©ºé—´å¯èƒ½å·²æ»¡ã€‚")}}}
        function deleteCustomTemplate(a){a&&customSpreadTemplates[a]&&confirm(`æ‚¨ç¡®å®šè¦åˆ é™¤è‡ªå®šä¹‰æ¨¡æ¿ "${a}" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)&&(delete customSpreadTemplates[a],localStorage.setItem("customTarotSpreads",JSON.stringify(customSpreadTemplates)),alert(`æ¨¡æ¿ "${a}" å·²åˆ é™¤ã€‚`),populateAllTemplateLists())}
    </script>
</body>
</html>
